# Задача по разработке приложения на React для Frontend-стажировки в Lad

## Описание задачи

Написать полноценное SPA (single page application) приложение (например блог, интернет магазин, админ панель, сайт визитка или любое другое веб-приложение), которое должно удовлетворять следующим условиям:

1. Стек `React` (или `NextJS`).
2. Функциональные компоненты, `React-hooks`.
3. `Модульные стили` или `styled-components`.
4. Роутинг `React-router-dom` или `NextJS`.
5. `Redux/ReduxToolKit`. Асинхронные экшены `Redux-thunk` или `Redux-saga`.
6. Работа с API с помощью клиента `Axios` (можно использовать любое открытое API либо свой вариант).

## Общее описание приложения

[**_Библиотека игральных карт Hearthstone_**](https://hearthstone-card-library.herokuapp.com/) - сервис для получения информации обо всех доступных картах из компьютерной игры `Hearthstone` производства Blizzard. Функционал приложения:

- Отображение игральных карт с возможностью получения детальной информации по каждой отдельной карте.
- Отображение доступных базовых героев (классов) с возможностью получения детальной информации по каждому классу (в т.ч. разных героев в рамках одного класса).
- Настройка отображения списков карт в соответствии с заданными параметрами или полнотекстовый поиск по базе данных.

### Соответствие приложения условиям задачи

- Стек `React`.
- React-компоненты реализованы в `функциональном стиле`, используются `react-hooks`.
- Модульные `sass` стили.
- Роутинг реализован при помощи `React Router v6`
- Используется `ReduxToolKit`. Асинхронные экшены отрабатываются при помощи `createAsyncThunk()`.
- HTTP запросы осуществляются с помощью `Axios`.

### Основные фичи приложения

- Минимизировано количество запросов к API - если текущее представление по картам или героям не менялось, то при рендере страницы повторный запрос к серверу осуществляться не будет (например, при переключении между страницами фильтрации, карт и героев или при возвращении к общему списку со страницы отдельной карты или героя).
- Реализована возможность повторного отображения содержимого конкретного рута при перезагрузке страницы (кроме страницы отдельной карты, т.к. не хватило времени реализовать этот функционал).
- При переходе по `несуществующему url` отображается заглушка с кнопкой, ведущей на домашнюю страницу c инициализацией перезагрузки страницы.
- Использована библиотека `Formik` для создания формы фильтрации запросов.
- Реализована обертка-предохранитель `ErrorBoundaries`, а также компонент ошибки при рендере отдельных страниц.
- Реализованы кастомные стили `input` компонентов и `полосы прокрутки` для соответствия общей стилистике приложения.
- Реализована верстка под Full HD и HD мониторы. Мобильную верстку и верстку под 2K мониторы не успел реализовывать.

### API

Использовался [Hearthstone API](https://develop.battle.net/documentation/hearthstone/game-data-apis) и следующие `эндпоинты`:

- `/metadata` - получение всех доступных данных о сущностях игры (классы героев, наборы карт, типы существ и т.п.). Данные используются в основном для настройки параметров отбора карт, а также для ассоциации `id` различных полей в объектах карт и героев с их текстовыми наименованиями (свойство `name` объекта с искомым `id`).

- `/cards` - получение списка карт, соответствующих определенному запросу. Важно отметить, что API возвращает карты в соответствии с их уникальными `id`. На практике часто будут отображаться визуально одинаковые карты, но при этом они не будут являться дублями, т.к. если одна и та же карта относится к разным наборам, то в базе ей будет присвоен уникальный `id` для каждого набора.

- `/deck` - предназначается для получения информации о вариантах колод карт по коду колоды или `ids` карт, составляющих колоду. В рамках данного приложения используется для получения данных о базовом герое (классе) и является единственной возможностью в этом отношении, т.к. базовый герой (класс) представляет собой отдельную сущность, и API не позволяет запрашивать сразу список `ids` базовых героев (классов), поэтому приходится осуществлять отдельный запрос для получения данных по каждому герою.

## Структура приложения

### `components`

Разделены на 3 папки:

- `appComponents` - составляют постоянную видимую структуру приложения:
  - `App` - основной компонент, отвечающий в т.ч. за маршрутизацию. Руты страниц отдельных карт и героев реализованы не как вложенные, т.к., по сути, каждый раз рендерится отдельная страница, а `outlet` должен был бы быть размещен в компоненте `MainSection`, по отношению к которому эти руты вложенными не являются.
  - `AppHeader` - шапка приложения, содержащая кнопки навигации и поле для полнотекстового поиска по базе данных.
  - `MainSection` - компонент-обертка, в котором рендерятся дочерние компоненты страниц. Сделан в т.ч. для того, чтобы рендерить спиннер и компонент ошибоки по центру.
- `minorComponents` - содержит все вспомогательные компоненты:
  - `SectionHeader` - содержит заголовок страницы, принимает текст для конкретной страницы в виде props.
  - `SectionLayout` - компонент-обертка, содержащий общий шаблон верстки страницы.
  - `NavBar` - содержит панель навигации в шапке приложения.
  - `FilterButton` - содержит кнопку перехода на страницу фильтров в шапке приложения.
  - `SearchField` - содержит компонент полнотекстового поиска в шапке приложения.
  - `PaginationButton` - содержит компонент кнопки для навигации по страницам в рамках `CardsListPage` (при выгрузке более 10 результатов) и `SingleHeroPage` (просмотр альтернативных изображений героев).
  - `TextComponent` - содержит стандартный текстовый компонент, использующийся при верстке отдельных страниц.
  - `TextFieldComponent` - содержит стандартный текстовый компонет, визуально оформленный в виде поля с текстом и использующийся при верстке отдельных страниц.
  - `Spinner` - содержит компонент спиннера.
  - `ErrorBoundary` - компонент-обертка, отлавливающий ошибки в рамках этапов жизненного цикла дочерних компонентов. Представляет собой классовый компонент, т.к. использует хук жизненного цикла `componentDidCatch()`. Не отлавливает ошибки внутри обработчиков событий и асинхронного кода. Для этого в рамках страниц рендерится отдельный компонент ошибки.
  - `ErrorMessage` - содержит компонент ошибки с кнопкой возврата на домашнюю страницу с автоматической перезагрузкой страницы. Принимаеи текст для отображения в виде props.
- `pages` - содержит все компоненты страниц, рендерящиеся в рамках `MainSection`:
  - `StartPage` - стартовая страница приложения с общей информацией.
    - `startSlice` - срез стора для работы с метаданными.
  - `CardsListPage` - страница для отображения полученных от API карт с указанием количества карт, соответствующих запросу, а также количество страниц (базовая настройка запроса - отображение 10 карт на странице). Запрос по умолчанию возвращает все доступные коллекционные карты (4000+ карт).
    - `cardsSlice` - срез стора для работы с данными о картах.
  - `SingleCardPage` - страница для отображения информации о конкретной карте.
  - `HeroesListPage` - страница, отображающая список всех доступных в игре на момент запроса героев (классов). Изображение класса "Охотник на демонов" отличается от других карт, но такие данные возвращает [Hearthstone API](https://develop.battle.net/documentation/hearthstone/game-data-apis).
    - `heroesSlice` - срез стора для работы с данными о героях.
  - `SingleHeroPage` - страница для отображения информации о конкретном герое. Позволяет получать альтернативные карты героев в рамках одного класса.
  - `FiltersPage` - страница, содержащая форму с полями выбора различных условий отбора карт. Данные в полях отбора получены из `metadata`. Форма создана при помощи библиотеки `Formik`.

### `styles`

- `styles.scss` - общие стили приложения.
- `variables.scss` - общие переменные, повторяющиеся в рамках стилей отдельных компонентов (здесь только цвета).

### `assets`

- `fonts` - содержит шрифт `Belwe` - официальный шрифт `Hearthstone`.
- `img` - содержит все статические изображения.

### `store`

Стор приложения содержит 3 отдельных среза.

### `services`

Содержит методы для правильной работы с [Hearthstone API](https://develop.battle.net/documentation/hearthstone/game-data-apis), а также объект с общими для всех запросов настройками.

### `hooks`

Содержит кастомый хук, экспортирующий функцию для осуществления запроса к API.

## Логика работы приложения

При запуске приложения рендерится `StartPage`:

- Запрашивается `токен` и сохраняется в `Session Storage` - решил сделать так, чтобы не писать проверку по дате экспирации. При выпуске один и тот же токен получает 3600s, поэтому нет уверенности, что это не задвоение данных от API, и если высчитывать дату экспирации в момент выпуска ключа и сохранять его в `Local Storage` - дата будет валидной. Поэтому решил ограничиться хранением токена в рамках сессии.
- Осуществляется запрос к API для получения `metadata`. Т.к. метаданные в дальнейшем используются практически на всех остальных страницах, логично получать их при старте приложения:

  - `FiltersPage` - формирование списков параметров фильтрации карт.
  - `HeroesListPage` - формирование списка `ids` классов героев с дальнейшим формированием списка карт героев и отображением их на странице.
  - `SingleCardPage` и `SingleHeroPage` - получение наименований (классы, типы, наборы и т.п.) по индексу.

При переходе на `CardsListPage` формируется список полученных по запросу карт. Навигация по страницам списка осуществляется при помощи изменения состояния свойства `currentPage`. Также срез содержит объект настроек текущего запроса `query`, который изменяется в зависимости от выбранных на странице фильтрации параметров.

`FiltersPage` - при сабмите формы сформированный объект обновляет `query` в срезе `cards`, происходит переход на `CardsListPage`, где отображаются карты в соответствии с обновленным объектом запроса.

В целом процесс запроса к API осуществляется за счет формирования строки `url` в соответствии с требуемыми параметрами. В случае со списками карт обязательно берутся в расчет данные из объекта `query`.

`HeroesListPage` - особенность работы этого компонента заключается в том, что для того, чтобы сформировать и отобразить список героев необходимо пройти 2 этапа:

- сформировать массив `ids` базовых героев (классов),
- сделать отдельный запрос к API для получения данных по каждому герою и сформировать массив из полученных объектов.
  Такие ограничения накладывает сам API, т.к. эндпоинт `/deck` не может отработать список `ids` базовых классовых героев. Поэтому в `ReduxDevTools` будут видны 10 запросов - по количеству отдельных героев. При этом получать список обыкновенных карт по `ids` можно - например, так получаются данные по альтернативным (небазовым) героям в рамках одного и того же класса для отображения в `SingleHeroPage`.

## Что можно улучшить

- Адаптивная верстка под планшеты, смартфоны и 2K мониторы.
- Сохранение текущих настроек на странице фильтрации и кнопка сброса фильтров.
- Повторное отображение содержимого при перезагрузке `SingleCardPage`.
